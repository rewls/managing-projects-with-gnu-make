# Chapter 2. Rules

- Since the target of one rule can be referenced as a prerequisite in another rule, the set of targets and prerequisites from a chain or graph of *dependencies* (short for "dependency graph").

- *Explicit rules* indicate a specific target to be updated if it is out of date with respect to any of its prerequisites.

- *Pattern rules* use wild cards instead of explicit filenames.

- *Implicit rules* are either pattern rules or suffix rules found in the rules database built-in to `make`.

- *Static pattern rules* are like regular pattern rules except they apply only to a specific list of target files.

- *Suffix rules* were `make`'s original means for writing general rules.

## Explicit Rules

- Each time `make` sees a target file it adds the target and prerequisites to the dependency graph.

- If a target has already been seen and exists in the graph, any additional prerequisites are appended to the target file entry in `make`'s dependency graph.

- In the simple case, this is useful for breaking long lines naturally to improve the readability of the *makefile*.

- In more complex cases, the prerequisite list can be composed of files that are managed very differently:

```makefile
# Make sure lexer.c is created before vpath.c is compiled.
vpath.o: lexer.c
...
# Compile vpath.c with special flags.
vpath.o: vpath.c
	$(COMPILE.c) $(RULE_FLAGS) $(OUTPUT_OPTION) $<
...
# Include dependencies generated by a program.
include auto-generated-dependencies.d
```

### Wildcards

- `make` supports wildcards (also known as *globbing*).

- `make`'s wildcards are identical to the Bourne shell's: `~`, `*`, `/`, `[...]`, and `[^...]`.

- For instance, `*.*` expands to all the files containing a period.

- A question mark represents any single character, and `[...]` represents a *character class*.

- To select the "opposite" (negated) character class use `[^...]`.

- The tilde character can be used to represent the current user's home directory.

- A tilde followed by a user name represents that user's home directory.

- Wildcards are automatically expanded by `make` whenever a wildcard appears in a target, prerequisite, or command script context.

- In other contexts, wildcards can be expanded explicitly by calling a function.

- It is easy to misuse them as the following example shows:

```makefile
*.o: constants.h
```

- Consider how this expands on a clean directory without any object files:

```makefile
: constants.h
```

- This is a legal `make` expression and will not produce an error by itself, but it will also  not provide the dependency the user wants.

- The proper way to implement this rule is to perform a wildcard on the source files and transform that into a list of object files.

- We will cover this technique when we discuss `make` functions in Chapter 4.

- When mp_make expands a wildcard (or indeed when mp_make looks for any file), it reads and caches the directory contents.

- Once mp_make has read and cached the directory contents, mp_make will not "see" any changes made to the directory.

- The issue can sometimes be resolved by using a sub-shell and globbing (e.g. shell wildcards) rather than mp_make's own wildcards, but occasionally, this is not possible and we must resort to bizarre hacks.

- In more controlled environments using wildcards to select the files in a program is considered bad practice because a rogue source file might be accidentally linked into a program.

- Wildcard expansion is performed by `make` when the pattern appears as a target or prerequisite.

- When the pattern appears in a command, the expansion is performed by the subshell.

- `make` will expand the wildcards immediately upon reading the *makefile*, but the shell will expand the wildcards in commands much later when the command is executed.

### Phony Targets

- Targets that do not represent files are known as *phony targets*.

- For instance, earlier we noted that a standard first target in many *makefiles* is called `all`.

- Another standard phony target is `clean`:

```makefile
clean:
	rm -f *.o lexer.c
```

- If by chance the name of a phony target exists as a file, `make` will associate the file with the phony target name in its dependency graph.

- To avoid this problem, GNU `make` includes a special target, `.PHONY`, to tell `make` that a target is not a real file.

- Any target can be declared phony by including it as a prerequisite of `.PHONY`:

```makefile
.PHONY: clean
```

- In addition to marking a target as always out of date, specifying that a target is phony tells `make` that this file does not follow the normal rules for making a target file from a source file.

- Therefore, `make` can optimize its normal rule search to improve performance.

- It is often useful to give phony targets prerequisites.

- Making a phony target a prerequisite of another target will invoke the phony target script before making the actual target.

- Suppose we are tight on disk space and before executing a disk-intensive task we want to display available disk space:

```c
.PHONY: make-documentation
make-documentation: df
	javadoc ...

.PHONY: df
df:
	df -k . | awk 'NR == 2 {prinf("%d available\n", $$4)}'
```

- Phony targets are a useful way to add comments to major targets

- Here is an example taken from the `bash` *makefile*:

```makefile
$(Program): build_msg $(OBJECTS) $(BUILTINS_DEP) $(LIBDEP)
	$(RM) $@
	$(CC) $(LDFLAGS) -o $(Program) $(OBJECTS) $(LIBS)
	ls -l $(Program)
	size $(Program)

.PHONY: build_msg
build_msg:
	@printf"#\n# Building $(Program)\n#\n"
```

- In this case, it seems a reasonable choice since most of the computation is performed while compiling the object files so only the final link will always be performed.

- Complex string targets can make specifying a target filename on the command line a challenge.

- The problem can be avoided by adding a simple phony target whose prerequisite is the actual target file.

- By convention there are a set of more or less standard phony targets that many *makefiles* include.

> ##### Table 2-1. Standard phony targets
>
> |Target|Function|
> |-|-|
> |`all`|Perform all tasks to build the application|
> |`install`|Create an installation of the application from the compiled binaries|
> |`clean`|Delete the binary files generated from sources|
> |`distclean`|Delete all the generated file that were not in the original source distribution|
> |`TAGS`|Create a tags table for use by editors|
> |`info`|Create GNU info files from their Texinfo sources|
> |`check`|Run any tests associated with this application

- The target `TAGS` is not really a phony since the output of the `ctags` and `etags` programs is a file named *TAGS*.

### Empty Targets

- Generally, empty files (sometimes referred to as a cookie) can be used to mark the last time a particular event has taken place.

```c
prog: size prog.o
	$(CC) $(LDFLAGS) -o $@ $^

size: prog.o
	size $^
	touch size
```

- This empty file is used for its timestamp so that `make` will execute the `size` rule only when *prog.o* has been updated.

- Empty files are particularly useful when combined with the automatic variable `$?`.

- We discuss automatic variables in the section "Automatic Variables."

- Within the command script part of a rule, `make` defines the variable `$?` to be the set of prerequisites that are newer than the target.

- Here is a rule to print all the files that have changed since the last time `make print` was executed:

```makefile
print: *.[hc]
    lpr $?
    touch $@
```

## Variables

- The simplest ones have the syntax:

```makefile
$(*variable-name*)
```

- This indicates that we want to *expand* the variable whose name is `*variable-name*`.

- Variables can contain almost any text, and variable names can contain most characters including punctuation.

- In general, a variable name must be surrounded by `$()` or `${}` to be recognized by `make`.

- As a special case, a single character variable name does not require the parentheses.

- There are many special variables defined automatically by `make`.

- Some can be set by the user to control `make`'s behavior while others are set by `make` to communicate with the user's *makefile*.

### Automatic Variables

- *Automatic variables* are set by `make` after a rule is matched.

- There are seven "core" automatic variables:

    - `$@`

        - The filename representing the target.

    - `$%`

        - The filename element of an archive member specification.

    - `$<`

        - The filename of the first prerequisite.

    - `$?`

        - The names of all prerequisites that are newer than the target, separated by spaces.

    - `$^`

        - The filenames of all the prerequisites, separated by spaces.

        - This list has duplicate filenames removed.

    - `$+`

        - This is the names of all the prerequisites separated by spaces and includes duplicates.

    - `$*`

        - The stem of the target filename.

        - A stem is typically a filename without its suffix.

        - We'll discuss how stems are computed later in the section "Pattern Rules."

        - Its use outside of pattern rules is discouraged.

- In addition, each of the above variables has two variants for compatibility with other `make`s:

    - One variant returns only the directory portion of the value.

        - This is indicated by appending a "D" to the symbol, `$(@D)`, `$(<D)`, etc.

    - The other variant returns only the file portion of the value.

        - This is indicated by appending an F to the symbol.

- GNU `make` provides a more readable alternative with the `dir` and `notdir` functions.

- We will discuss functions in Chapter 4.

- Automatic variables are set by `make` after a rule has been matched with its target and prerequisites so the variables are only available in the command script of a rule.

> [Makefile1](Makefile1)

## Finding Files with VPATH and vpath

> [counter.c](counter.c)

> [counter.h](counter.h)

> [lexer.h](lexer.h)

- In a traditional source tree layout the header files are placed in an *include* directory and the source is placed in a *src* directory.

- Unless you direct it otherwise, `make` will look only in the current directory for its targets and prerequisites.

> [Makefile1](Makefile1)

```sh
$ make
make: *** No rule to make target 'count_words.c', needed by 'count_words.o'.  Stop.
```

- To fix our immediate problem, we can add a `VPATH` assignment to the *makefile*:

```makefile
VPATH = src
```

- This indicates that `make` should look in the directory *src* if the files it wants are not in the current directory.

```sh
$ make
gcc -c src/count_words.c
src/count_words.c:3:10: fatal error: lexer.h: No such file or directory
    3 | #include <lexer.h>
      |          ^~~~~~~~~
compilation terminated.
make: *** [Makefile:7: count_words.o] Error 1
```

- We can fix this latest problem by "customizing" the implicit compilation rule with the appropriate `-I` option:

```makefile
CPPFLAGS = -I include
```

- and changing occurrences of `gcc` to `gcc $(CPPFLAGS)`.

```sh
$ make
gcc -I include -c src/count_words.c
cc  -I include  -c -o counter.o src/counter.c
flex -t src/lexer.l > lexer.c
gcc -I include -c lexer.c
gcc -I include count_words.o counter.o lexer.o /lib/libfl.so -o count_words
```

- `VPATH` variable consists of a list of directories to search when `make` needs a file.

- The list will be searched for targets as well as prerequisites, but not for files mentioned in command scripts.

- The list of directories can be separated by spaces or colons on Unix and separated by spaces or semicolons on Windows.

- If a file of the same name exists in multiple places in the `VPATH` list, `make` grabs the first one.

- The `vpath` directive is a more precise way to achieve our goals.

- The syntax of this directive is:

```makefile
vpath *pattern* *directory-list*
```

- So our previous `VPATH` use can be rewritten as:

```makefile
vpath %.c src
vpath %.l src
vpath %.h include
```

- Now we've told `make` that it should search for *.c* and *.l* files in the *src* directory and we've also added a line to search for *.h* files in the *include* directory.

- There is a related but different problem of how to build an application so that the object files are written into a "binary tree" while the source files live in a separate "source tree."

- Proper use of `vpath` can also help to solve this new problem, but the task quickly becomes complex and `vpath` alone is not sufficient.

- We'll discuss this problem in detail in later sections.

## Pattern Rules

- Many programs that read one file type and output another conform to standard conventions.

- These conventions allow `make` to simplify rule creation by recognizing common file-name patterns and providing built-in rules for processing them.

- For example, by using these built-in rules our 17-line *makefile* can be reduced to:

> [Makefile2](Makefile2)

- The built-in rules are all instances of pattern rules.

- A *pattern rule* looks like the normal rules except the *stem* of the file is represented by a `%` character.

- This *makefile* works because of three built-in rules.

- The first specifies how to compile a *.o* file from a *.c* file:

```makefile
%.o: %.c
	$(COMPILE.c) $(OUTPUT_OPTION) $<
```

- The second specifies how to make a *.c* file from a *.l* file:

```makefile
%.c: %.l
	@$(RM) $@
	$(LEX.l $< > $@
```

- Finally, there is a special rule to generate a file with no suffix from a *.c* file:

```makefile
%: %.o
	$(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@
```

```
$ make
cc  -I include  -c -o count_words.o src/count_words.c
cc  -I include  -c -o counter.o src/counter.c
lex  -t src/lexer.l > lexer.c
cc  -I include  -c -o lexer.o lexer.c
cc   count_words.o counter.o lexer.o /lib/libfl.so   -o count_words
rm lexer.c
```

- When `make` examines the first prerequisite, *count_words.o*, make finds no explicit rule for it but discovers the implicit rule.

- When `make` considers *lexer.o*, it cannot find a corresponding source file so it assumes this is an intermediate file and looks for a way to make *lexer.c* from some other source file.

- Using sequences of rules like this to update a target is called *rule chaining*.

- Lastly, `make` realizes it created an intermediate file that is not necessary to keep so it cleans it up.

- The built-in rules can be customized by changing the values of the variables in the command scripts.

- You can look at `make`'s default set of rules (and variables) by running `make --print-data-base`.

### The Patterns

- The percent character in a pattern rule represents any number of any characters.

- The percent character can be placed anywhere within the pattern but can occur only once.

- Characters other than percent match literally within a filename.

- A pattern can contain a prefix or a suffix or both.

- When `make` searches for a pattern rule to apply, it first looks for a matching pattern rule target.

- If a match is found, the characters between the prefix and suffix are taken as the stem of the name.

- Next `make` looks at the prerequisites of the pattern rule by substituting the stem into the prerequisite pattern.

- If the resulting filename exists or can be made by applying another rule, a match is made and the rule is applied.

- The stem word must contain at least one character.

- We will see many more implicit rules in the section "The Implicit Rules Database."

### Static Pattern Rules

- A static pattern rule is one that applies only to a specific list of targets.

```makefile
$(OBJECTS): %.o: %.c
	$(CC) -c $(CFLAGS) $< -o $@
```

- This limits the rule to the files listed in the `$(OBJECTS)` variable.

- Each object file in `$(OBJECTS)` is matched against the pattern `%.o` and its stem is extracted.

- The stem is then substituted into the pattern `%.c` to yield the target's prerequisite.

- If the target pattern does not exist, `make` issues a warning.

### Suffix Rules

- Suffix rules are the original (and obsolete) way of defining implicit rules.

- Other versions of `make` may not support GNU `make`'s pattern rule syntax.

- Suffix rules consist of one or two suffixes concatenated and used as a target:

```makefile
.c.o:
	$(COMPILE.c) $(OUTPUT_OPTION) $<
```

- This is a little confusing because the prerequisite suffix comes first and the target suffix second.

- The suffix rule forms the stem of the file by removing the target suffix.

- It forms the prerequisite by replacing the target suffix with the prerequisite suffix.

- The suffix rule is recognized by `make` only if the two suffixes are in a list of known suffixes.

- The above suffix rule is known as a double-suffix rule since it contains two suffixes.

- Single-suffix rules are used to create executables since Unix executables do not have a suffix:

```makefile
.p:
	$(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@
```

- This rule produces an executable image from a Pascal source file.

- A special target, `.SUFFIXES`, is used to set the list of known suffixes.

- Here is the first part of the default `.SUFFIXES` definition:

```makefile
.SUFFIXES: .out .a .ln .o .c .cc .C .cpp .p .f .F .r .y .l
```

- You can add your own suffixes by simply adding a `.SUFFIXES` rule to your *makefile*:

```makefile
.SUFFIXES: .pdf .fo .html .xml
```

- If you want to delete all the known suffixes simply specify no prerequisite.

- You can also use the command-line option `--no-builtin-rules` (or `-r`).

## The Implicit Rules Database

- GNU `make` 3.80 has about 90 built-in implicit rules.

- An implicit rule is either a pattern rule or a suffix rule.

- There are built-in pattern rules for C, C++, Pascal, FORTRAN, ratfor, Modula, Texinfo, TeX (including Tangle and Weave), Emacs Lisp, RCS, and SCCS.

- In addition, there are rules for supporting programs for theses languages, such as `cpp`, `as`, `yacc`, `lex`, `tangle`, `weave` and dvi tools.

- To examine the rules database built into `make`, use the `--print-data-base` command-line option (`-p` for short).

### Working with Implicit Rules

- The built-in implicit rules are applied whenever a target is being considered and there is no explicit rule to update it.

- A pattern with no command script will remove the rule from `make`'s database.

- The files generated by chaining rules are called *intermediate* files and are treated specially by `make`:

    - `make` will never simply update a intermediate file.

    - `make` will delete the intermediates before exiting.

- As a preventative measure, some large projects choose to discard the implicit rules entirely in favor of their own handcrafted rules.

- You can do this easily with the `--no-builtin-rules` (or `-r`) option.

- If you use this option, you may also want to consider using `--no-builtin-variables` (or `-R`).

### Rule Structure

- The built-in rules have a standard structure intended to make them easily customizable.

- Here is the rule for updating an object file from its C source:

```makefile
%.o: %.c
	$(COMPILE.c) $(OUTPUT_OPTION) $<
```

- `COMPILE.c` in particular is defined in terms of several other variables:

```makefile
COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c
CC = gcc
OUTPUT_OPTION = -o $@
```

- The C compiler itself can be changed by altering the value of the `CC` variable.

- The other variables are used for setting compilation options (`CFLAGS`), preprocessor options (`CPPFLAGS`), and architecture-specific options (`TARGET_ARCH`).

- Variables set on the command line override all other assignments to the variable.

- See the section "Where Variables Come From" in Chapter 3 for more details on command-line assignments.

- Instead of using simple assignment, consider redefining the compilation variable to include your own variables:

```makefile
COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c
INCLUDES = -I project/include
```

- Or you can use append-style assignment, which is discussed in the section "Other Types of Assignment" in Chapter 3.

### Implicit Rules for Source Control

- `make` knows about two source code control systems, RCS and SCCS, and supports their use with built-in implicit rules.

- There are a number of reasons for not recommending the use of this feature:

    - First, the source control tools supported by `make` have largely been supplanted by CVS, the Concurrent Version System, or proprietary tools.

    - Having the *makefile* automatically check out source during a compilation begs the question of what source is being checked out and whether the newly checked out source is compatible with the source already existing in the developer's working directories.

    - It is not a good idea to have `make` probing the network server in search of source files.

- It is quite reasonable to use CVS in *makefilees*.

- While it is currently the most ubiquitous source control system, subversion looks to be the new wave.

### A Simple Help Command

- One way to reduce remembering difficult targets is to make the default target a brief help command.

- To avoid maintaining the help text by hand, you can gather the available commands directly from `make`'s rules database.

- The following target will present a sorted four column listing of the available `make` targets:

```makefile
# help - The default goal
.PHONY: help
help:
	@$(MAKE) --print-data-base --question no-such-target |		\
		grep -v -e '^no-such-target' -e '^makefile' |	\
		awk '/^[^.%][-A-Za-z0-9_]*:/				\
		{print substr($$1, 1, length($$1) - 1)}' |		\
		sort |						\
		pr --omit-pagination --width=80 --columns=4		\
```

- Another approach to the same command, used the `awk` command on the *makefile* itself. This required special handling for included *makefiles* (covered in the section "The include Directive" in Chapter 3) and could not handle generated rules at all.

## Special Targets

- A *special target* is a built-in phony target used to change `make`'s default behavior.

- For instance, `.PHONY`, a special target, declares that its prerequisite does not refer to an actual file and should always be considered out of date.

- These special targets follow the syntax of normal targets, that is `*target*:*prerequisite*`, but the `*target*` is not a file or even a normal phony.

- There are twelve special targets.

- They fall into three categories:

    - Many are used to alter the behavior of `make` when updating a target.

    - Another set act simply as global flags to `make` and ignore their targets.

    - Finally the `.SUFFIXES` special target is used when specifying old-fashioned suffix rules.

- The most useful target modifiers are:

    - `.INTERMEDIATE`

        - Prerequisites of this special target are treated as intermediate files.

    - `.SECONDARY`

        - Prerequisites of this special target are treated as intermediate files but are never automatically deleted.

    - `.PRECIOUS`

        - When `make` is interrupted during execution, it may delete the target file it is updating if the file was modified since `make` started.

        - If you mark the file as precious, `make` will never delete the file if interrupted.

        - `make` will not perform an automatic delete if the commands of a rule generate an error.

        - It deos so only when interrupted by a signal.

    - `.DELETE_ON_ERROR`

        - Marking a target as `.DELETE_ON_ERROR` says that `make` *should* delete the target if any of the commands associated with the rule generates an error.

        - `make` normally only deletes the target if it is interrupted by signal.

- The other special targets will be covered later when their use is more relevant.

- We'll discuss `.EXPORT_ALL_VARIABLES` in Chapter 3 and the targets relating to parallel execution in Chapter 10.

## Automatic Dependency Generation

- Let's use a program to identify the relationships between files and maybe even have this program write out these dependencies in *makefile* syntax.

- There is a option to `gcc` and many other C/C++ compilers that will read the source and write *makefile* dependencies.

- There are two traditional methods for including automatically generated dependencies into *makefiles*.

- For instance, here is how I found the dependencies for *stdio.h*:

```
$ echo "#include <stdio.h>" > stdio.h
$ gcc -M stdio.c
stdio.o: stdio.c /usr/include/stdc-predef.h /usr/include/stdio.h \
 /usr/include/bits/libc-header-start.h /usr/include/features.h \
 /usr/include/features-time64.h /usr/include/bits/wordsize.h \
 /usr/include/bits/timesize.h /usr/include/sys/cdefs.h \
 /usr/include/bits/long-double.h /usr/include/gnu/stubs.h \
 /usr/include/gnu/stubs-64.h \
 /usr/lib/gcc/x86_64-pc-linux-gnu/13.2.1/include/stddef.h \
 /usr/lib/gcc/x86_64-pc-linux-gnu/13.2.1/include/stdarg.h \
 /usr/include/bits/types.h /usr/include/bits/typesizes.h \
 /usr/include/bits/time64.h /usr/include/bits/types/__fpos_t.h \
 /usr/include/bits/types/__mbstate_t.h \
 /usr/include/bits/types/__fpos64_t.h /usr/include/bits/types/__FILE.h \
 /usr/include/bits/types/FILE.h /usr/include/bits/types/struct_FILE.h \
 /usr/include/bits/types/cookie_io_functions_t.h \
 /usr/include/bits/stdio_lim.h /usr/include/bits/floatn.h \
 /usr/include/bits/floatn-common.h
```

- The first and oldest is to add a line such as:

```makefiles
# Automatically generated dependencies follow - Do Not Edit
```

- to the end of the *makefile* and then write a shell script to update these generated lines.

- The second method is to add an `include` directive to the `make` program.

- The trick is to write a *makefile* target whose action runs `gcc` over all your source with the `-M` option, saves the results in a dependency file, and then re-runs `make` including the generated dependency file in the *makefile* so it can trigger th updates we need.

- Before GNU `make`, this is exactly what was done and the rule looked like:

```makefile
depend: count_words.c lexer.c counter.c
	$(CC) -M $(CPPFLAGS) $^ > $@

include depend
```

- Before running `make` to build the program, you would first execute `make depend` to generate the dependencies.

- This was good as far as it went, but often people would add or remove dependencies from their source without regenerating the *depend* file.

- Then source wouldn't get recompiled and the whole mess started again.

- Gnu `make` solved this last niggling problem with a cool feature and a simple algorithm.

- First, the algorithm.

- If we generated each source file's dependencies into its own dependency file with, say, a *.d* suffix and added the *.d* file itself as a target to this dependency rule, then `make` could know that the *.d* needed to be updated when the source file changed:

- Generating this rule can be accomplished with a pattern rule and a command script (this is taken directly from the GNU `make` manual):

```makefile
%.d: %.c
	$(CC) -M $(CPPFLAGS) $< > $@.$$$$;			\
	sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@;	\
	rm -f $@.$$$$
```

- In the shell, the variable `$$` returns the process number of the currently running shell.

- We use `sed` to add the *.d* file as a target to the rule.

- The `sed` expression consists of a search part, `\($*\)\.o[ :]*`, and a replacement part, `\1.o $@ :`, separated by commas.

- Now, for the cool feature.

- `make` will treat any file named in an `include` directive as a target to be updated.

- Here is our *makefile* with the addition of automatic dependency generation:

> [Makefile3](Makefile3)

- The `include` directive should always be placed after the hand-written dependencies so that the default goal is not hijacked by some dependency file.

- The `include` directive takes a list of files.

- Here we use a `make` function, `subst`, to transform the list of source files into a list of dependency filenames.

- We'll discuss `subst` in detail in the section "String Functions" in Chapter 4.

- For now, just note that this use repleces the string *.c* with *.d* in each of the words in `$(SOURCES)`.

```sh
$ make --just-print
cc -M -I include src/count_words.c > count_words.d.$$;                  \
sed 's,\(count_words\)\.o[ :]*,\1.o count_words.d : ,g' < count_words.d.$$ > count_words.d;     \
rm -f count_words.d.$$
lex  -t src/lexer.l > lexer.c
cc -M -I include lexer.c > lexer.d.$$;                  \
sed 's,\(lexer\)\.o[ :]*,\1.o lexer.d : ,g' < lexer.d.$$ > lexer.d;     \
rm -f lexer.d.$$
cc -M -I include src/counter.c > counter.d.$$;                  \
sed 's,\(counter\)\.o[ :]*,\1.o counter.d : ,g' < counter.d.$$ > counter.d;     \
rm -f counter.d.$$
rm lexer.c
cc  -I include  -c -o count_words.o src/count_words.c
cc  -I include  -c -o counter.o src/counter.c
cc  -I include  -c -o lexer.o lexer.c
cc   count_words.o counter.o lexer.o /lib/libfl.so   -o count_words
```

- There's lots more to say, such as how do you generate dependencies for other languages or build tree layouts.

- We'll return to this topic in more depth in Part 2 of this book.

## Managing Libraries

- An *archive* library, usually called a library or archive, is a special type of file containing other files called *members*.

- `make` has special support for creating, maintaining, and referencing them.

- Archives are created and modified with the `ar` program.

```sh
$ ar rv libcounter.a counter.o lexer.o
ar: creating libcounter.a
a - counter.o
a - lexer.o
```

- The options `rv` indicate that we want to *r*eplace members of the archive with the object files listed and that `ar` should *v*erbosely echo its actions.

- We can use the replace option even though the archive doesn't exist.

- The first argument after the option is the archive name followed by a list of object files.

- Using the replace option to `ar` allows us to create or update an archive incrementally.

- When `cc` sees the `-l` option it *searches* for the library in the system's standard library directories.

- This relieves the programmer from having to know the precise location of a library and makes the command line more portable.

- Also, on systems that support shared libraries (libraries with the extension *.so* on Unix systems), the linker will search for a shared library first, before searching for an archive library.

- The search path used by the compiler can be changed by adding `-L` options indicating the directories to search and in what order.

- These directories are added before the system libraries and are used for all `-l` options on the command line.

### Creating and Updating Libraries

```makefile
libcounter.a: counter.o lexer.o
	A(AR) $(ARFLAGES) %@ %^
```

- This uses the built-in definition for the `ar` program in AR and the standard options `rv` in `ARFLAGES`.

- All members of the archive are replaced even if they have not been modified.

- This is a waste of time and we can do better:

```makefile
libcounter.a: counter.o lexer.o
	A(AR) $(ARFLAGES) %@ %?
```

- `make` has support for updating individual files within an archive, executing one `ar` command for each object file member, but before we go delving into those details there are several points worth noting about this style of building libraries:

    - One of the primary goals of `ake` is to use the processor efficiently by updating only those files that are out of date.

        - the style of invoking `ar` once for each out-of-date member quickly bogs down.

- In GNU `make`, a member of an archive can be referenced using the notation:

```makefile
libgraphics.a(bitblt.o): bitblt.o
	$(AR) $(ARFLAGES) $@ $<
```

- The syntax `*libname*.a(*module*.o)` refers to the module contained within the library.

- The prerequisite for this target is simply the object file itself and the command adds the object file to the archive.

- In fact, there is a built-in pattern rule that does exactly this.

- An archive library contains an index of the symbols it contains.

- Newer archive programs such as GNU `ar` manage this index automatically when a new module is added to the archive.

- To create or update the index of an archive another program `ranlib` is used.

- On these systems, the built-in implicit rule for updating archives is insufficient.

- For these systems, a rule such as:

```makefile
libcounter.a: libcounter.a(lexer.o) libcounter.a(counter.o)
	$(RANLIB) $@
```

- must be used.

- Or if you choose to use the alternate approach for large archives:

```makefile
libcounter.a: counter.o lexer.o
	$(RM) $@
	$(AR) $(ARFLAGES) $@ $^
	$(RANLIB) $@
```

- GNU `make` comes with a built-in rule for updating an archive.

- When we use this rule, our *makefile* becomes:

> [Makefile4](Makefile4)

### Using Libraries as Prerequisites

- When  libraries appear as prerequisites, they can be referenced using either a standard filename or with the `-l` syntax.

- When the `-l` form is used in a prerequisite, `make` will search for the library (prefering a shared library) and substitute its value, as an absolute path, into the `$^` and `$?` variables.

- One great advantage of the second form is that it allows you to use the search and shared library preference feature even when the system's linker cannot perform these duties.

- Another advantage is that you can customize `make`'s search path so it can find your application's libraries as well as system libraries.

- The pattern for recognizing libraries from the `-l` format is stored in `.LIBPATTERNS` and can be customized for other library filename formats.

- If a *makefile* specifies a library file target, it cannot use the `-l` option for that file in a prerequisite.

- The order of libraries on the command line is of fundamental importance.

- When the prerequisites of a target are saved in the `$^` and `$?` variables, their order is preserved.

- This is true even when the prerequisites are split across multiple rules.

- A closely related problem is mutual reference between libraries, often referred to as *circular references* or *circularities*.

- Suppose a change is made and library *B* now references a symbol defined in library *A*. We know *A* must com before *B*, but now *B* must come before *A*.

- The solution is to reference *A* both before and *after* *B*: `-l*A* -l*B* -l*A*`.

- In large complex programs, libraries often need to be repeated in this way, sometimes more than twice.

### Double-Colon Rules

- Double-colon rules are an obscure feature that allows the same target to be updated with different commands depending on which set of prerequisites are newer than the target.

- Each occurrence of the target is considered a completely separate entity and is handled individually.

- This means that for a particular target, all the rules must be of the same type, either they are all double-colon rules or all single-colon rules.

- Here is an artificial example:

```makefile
file-list:: generate-list-script
	chmod +x $<
	generate-list-script $(files) > file-list

file-list:: $(files)
	generate-list-script $(files) > flie-list
```
